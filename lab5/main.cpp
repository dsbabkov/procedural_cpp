
/*************************************************************
	Практическое занятие №5. 
	"Старые" потоковые функции стандартной библиотеки
	Указатели на функции
	Структуры
*************************************************************/

#define stop {int temp = 1; temp += 2;}

#include <iostream>
#include <cmath>
#include "other.h"
#include "book.h"
#include <algorithm>

Book globalBook;



int main()
{
	goto structs;
	{
		//Тема "Старые" потоковые функции стандартной библиотеки
		//Задание 1. С помощью функции scanf сформирйуте три коэффициента: A,B,C
		int a, b, c;
		printf("Input a, b, c: ");
		scanf("%d %d %d", &a, &b, &c);

		stop;

	//Задание 2. Выведите (красиво!) таблицу значений y=A*x*x + B*x + C
	//при изменении x в диапазоне -2 до +2 с шагом 0.5
		double lbound = -2;
		double ubound = 2;
		double step = 0.5;

		int stepCount = (ubound - lbound) / step;
		for (int i = 0; i <= stepCount; ++i) {
			double x = lbound + step * i;
			double y = a * x * x + b * x + c;
			printf("x = %8g, \ty = %8g\n", x, y);
		}
	}
	stop

    {


		///////////////////////////////////////////////////////////////////
			//Тема Указатели на функции

			//Задание 1. Указатель на функцию. "Калькулятор".
			//Напишите функции:
			//1)Sum - принимает два значения double и возвращает сумму
			//этих значений
			//2)Sub- принимает два значения double и возвращает разность
			//этих значений
			//3)Mul - *
			//4)Div - /
			//5)а для возведения в степень можете использовать функцию стандартной библиотеки
			//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
			//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
			//		вариантов этой функции, а Вам потребуется сформировать указатель на 
			//		double pow(double, double);

			//Предоставьте пользователю	следующую возможность:
			//пока пользователь хочет пользоваться услугами Вашего калькулятора,
			//он может вводить два значения и знак операции
			//а Вы выводите результат. Результат получаете посредством вызова
			//соответствующей Вашей функции по указателю.
			//Предусмотрите возможность ввода непредусмотренного знака операции

	char key[] =                       { '+', '-', '*', '/', '^' };

	double(*fun[]) (double, double) = { &Sum, &Sub, &Mul, &Div, &pow };
	int funCount = sizeof(key);

	double left = -1;
	double right = -1;

	while (true) {
		printf("Input binary expression:\n");
		double left = 0;
		double right = 0;
		char operation;
		scanf("%lf %c %lf", &left, &operation, &right);

		int operationId = indexOf(key, funCount, operation);
		if (operationId == -1) {
			printf("Wrong operation. End of calculation.\n");
			break;
		}

		double answer = fun[operationId](left, right);
		printf("= %g\n", answer);
	}
	
	stop

	//Задание 2. Указатель на функцию в качестве аргумента.
	//Дана заготовка функции сортировки любых объектов - Sort.
	//Функция принимает следующие параметры:
	//1) указатель на первый сортируемый элемент
	//2) количество сортируемых элементов
	//3) размер элемента в байтах
	//4) указатель на функцию перестановки элементов
	//5) указатель на функцию сравнения элементов

	//2a. Напишите функцию перестановки двух целых значений -
	// SwapInt, которая принимает два void указателя и 
	//меняет значения местами

	//Напишите функцию сравнения двух целых значений -
	// CmpInt, которая принимает два void указателя и
	//возвращает int результат сравнения: 
	//<0 - первый элемент меньше, чем второй
	//=0 - равны
	//>0 - первый элемент больше, чем второй
	{
		int nAr[] = {2, 3, 1, 2, 3, 5, 6, 23, 1, 0};	//массив для сортировки
		int n = sizeof(nAr) / sizeof(*nAr);
		//Печать исходного массива
		printArray(nAr, n);


		//Вызов сортировки
		Sort(reinterpret_cast<char*>(&nAr[0]), n, sizeof(int), SwapInt, CmpInt);

		//Печать результатов сортировки
		printArray(nAr, n);
		stop

			
				//Задание 2б. По аналогии с 8а создайте вспомогательные
				//функции - SwapDouble и CmpDouble и вызовите функцию Sort
				//для сортировки массива вещественных значений.
		{
			double nAr[] = { 2, 3, 1, 2, 3, 5, 6, 23, 1, 0 };	//массив для сортировки
			int n = sizeof(nAr) / sizeof(*nAr);
			printArray(nAr, n);
			Sort(reinterpret_cast<char*>(&nAr[0]), n, sizeof(double), SwapDouble, CmpDouble);
			printArray(nAr, n);
			stop
		}


		{
			//Задание 2в*. По аналогии с 8а создайте вспомогательные
			//функции - SwapStr и CmpStr и вызовите функцию Sort
			//для сортировки массива указателей на строки.
			char* arStr[] = { "QQQ", "SDF", "ABC" };
			int n = sizeof(arStr) / sizeof(*arStr);
			printArray(arStr, n);
			Sort(reinterpret_cast<char*>(&arStr[0]), n, sizeof(char*), SwapStr, CmpStr);
			printArray(arStr, n);
			stop

		}

			
	}
	
	{
		//Задание 3. Массивы указателей на функцию.
		//Напишите несколько функций вида
		//const char* GetString1();
		//const char* GetString2();
		//		...., каждая из функций возвращает указатель на свою строку
		//(подумайте - какой адрес Вы имеете право возвращать из функции)


		//Объявите и проинициализируйте массив указателей на функции
		//GetString1,GetString2...

		const char * (*get[])() = { &GetString1, &GetString2 };

			//Введите номер функции, которую Вы хотите вызвать:
			int n = 1;



		//Вызовите функцию 
			const char * res = get[n]();



		//Распечатайте результат
			printf("%s", res);
			delete[] res;
			stop
	}
    }

//////////////////////////////////////////////////////////////////////////////////////

	structs:
	//Тема. Структуры С.	
	//Задание 1. Объявите структуру BOOK, описывающую книгу
	//(автор, заглавие, год издания, цена, категория…).
	//Подумайте: какого типа могут быть поля структуры.
	//Подсказка: объявление структуры рекомендуется выносить
	//в заголовочный файл.


	//Задание 2. Создайте разными способами (глобальный, локальный, статический,
	//динамический) экземпляры (объекты) типа BOOK (без инициализации).
	//Определите - сколько памяти отводит компилятор под каждый
	//такой объект. Как инициализируются (или не инициализируются) поля
	//структуры. Подумайте: от чего зависит объем выделяемой памяти?
	{
		static Book staticBook;
		Book localBook;

		int glob = sizeof(globalBook);
		int stat = sizeof(staticBook);
		int loc = sizeof(localBook);
		stop




			//Задание 3. Заполните поля созданных объектов.
			//Замечание: если для хранения строки используется массив, необходимо
			//предусмотреть "защиту" от выхода за границы массива.
        printf("Global book:\n");
        inputBook(globalBook);
//        printf("Static book:\n");
//        inputBook(globalBook);
//        printf("Local book:\n");
//        inputBook(globalBook);

		stop
	}


	//Задание 4. Напишите функцию, выводящую на экран реквизиты книги.
	//Подумайте: как эффективнее передавать экземпляр BOOK в функцию.
	//Для вывода на консоль используйте функцию стандартной библиотеки
	//printf
    {
        printBook(globalBook);
    }



	//Задание 5. Напишите функцию для формирования полей структуры.
	//Для ввода используйте функцию стандартной библиотеки scanf
	//Замечание: неплохо заложить в такую функцию возможность проверки
	//корректности введенного значения, например, год издания не может быть
	//меьше, чем... (год появления письменности), категорию ползователь
	//должен выбирать из существующих, цена не может быть отрицательной...


	return 0;
}//main

